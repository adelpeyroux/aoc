(defun range (start end)
  (labels ((recrange (current lst)
             (if (>= current start)
                 (recrange (1- current) (cons current lst))
                 lst)))
    (recrange (1- end) '())))

(defun build-empty-map (dimensions init)
  (make-array dimensions :initial-element init))

(defun make-index (i j)
  (cons i j))

(defun i (index)
  (car index))

(defun j (index)
  (cdr index))

(defun index-is-valid (index array)
  (and
   (< -1 (i index) (array-dimension array 0))
   (< -1 (j index) (array-dimension array 1))))

(defun fill-line (array line content)
  (labels ((filler (cursor content)
             (if (and (>= cursor 0) (< cursor (array-dimension array 1)))
                 (progn
                  (setf (aref array line cursor) (car content))
                  (filler (1+ cursor) (cdr content)))
                 array)))
    (filler 0 content)))

(defun read-lines (lines)
  (let ((input (read-line *standard-input* nil)))
    (if input
        (read-lines (cons input lines))
        (reverse lines))))

(defun to-array (lines)
  (let ((array (build-empty-map (list (length lines) (length (car lines))) nil)))
    (labels ((add-line (line input)
               (fill-line array line (coerce input 'list))))
      (progn
        (mapc #'add-line (range 0 (array-dimension array 0)) lines)
        array))))

(defun dist (p1 p2)
  (+ (abs (- (i p2) (i p1)))
     (abs (- (j p2) (j p1)))))

(defun indices (array)
  (let ((result '()))
    (progn
      (dotimes (i (array-dimension array 0))
        (dotimes (j (array-dimension array 1))
          (when (char-not-equal (aref array i j) #\.)
            (push (make-index i j) result))))
      (reverse result))))

(defun swap-in-array (array first-index second-index)
  (let* ((v1 (aref array (i first-index) (j first-index)))
         (v2 (aref array (i second-index) (j second-index))))
    (setf (aref array (i first-index) (j first-index)) v2)
    (setf (aref array (i second-index) (j second-index)) v1)))

(defun transpose (array)
  (let ((result (make-array (reverse (array-dimensions array))
                            :initial-element #\.)))
    (dotimes (i (array-dimension array 0))
      (dotimes (j (array-dimension array 1))
        (setf (aref result j i) (aref array i j))))
    result))

(defun void-rows (array)
  (labels ((row-is-void (array row)
             (dotimes (c (array-dimension array 1))
               (when (char-equal (aref array row c) #\#)
                 (return-from row-is-void nil)))
             T)
           (rec-fn (row result)
             (if (= row (array-dimension array 0))
                 (reverse result)
                 (if (row-is-void array row)
                     (rec-fn (1+ row) (cons row result))
                     (rec-fn (1+ row) result)))))
    (rec-fn 0 '())))

(defun compute-expansion (array)
  (cons (void-rows array) (void-rows (transpose array))))

(defun apply-expansion (index exps factor)
  (labels ((expanse (value exp result)
             (if exp
                 (if (< (car exp) value)
                     (expanse value (cdr exp) (+ (* (1- factor) 1) result))
                     (expanse value (cdr exp) result))
                 (+ result value))))
    (let ((rexp (car exps))
          (cexp (cdr exps)))
      (make-index (expanse (i index) rexp 0)
                  (expanse (j index) cexp 0)))))

(defun pairs (lst)
  (labels ((tail-rec (lst result)
             (if lst
                 (tail-rec (cdr lst) (append (mapcar (lambda (x)
                                                       (cons (car lst) x))
                                                     (cdr lst))
                                             result))
                 (reverse result))))
    (tail-rec lst '())))

(defun solve-01 (array)
  (let* ((stars (indices array))
         (exps-indices (compute-expansion array))
         (expanded (mapcar (lambda (s)
                             (apply-expansion s exps-indices 2))
                           stars))
         (paired (pairs expanded))
         (dists (mapcar (lambda (p)
                          (dist (car p) (cdr p)))
                        paired)))
    (apply #'+ dists)))

(defun solve-02 (array)
  (let* ((stars (indices array))
         (exps-indices (compute-expansion array))
         (expanded (mapcar (lambda (s)
                             (apply-expansion s exps-indices 1000000))
                           stars))
         (paired (pairs expanded))
         (dists (mapcar (lambda (p)
                          (dist (car p) (cdr p)))
                        paired)))
    (apply #'+ dists)))

(defun process (file solver)
  (let* ((content (with-open-file (*standard-input* file)
                    (read-lines '())))
         (array (to-array content)))
    (funcall solver array)))
